#! /bin/python

import math
from pprint import pprint


# NOTE: Этот скрипт можно удалить. Это неудачная попытка найти коэффициент усечения диаметра окружностей при применении модификатора SubSurf



# С включенной опцией Use Limit Surface
# NOTE: Для одного миллиметра в диаметре при 64 подразделений существует погрешность 0.001605 (нужно найти также для другого количества подразделений)



# Усечение в диаметре в мм с включенной опцией Use Limit Surface для 100 мм диаметра:

print('*'*10, 'Усечения в диаметре для круга с диаметром 100 мм:')
subdiv_D100mm = [
    (8,  4.88156 * 2,),  # Значения указаны для радиуса, поэтому умножаем на 2 чтобы получить значение для диаметра
    (12, 2.23291 * 2,),
    (16, 1.26868 * 2,),
    (20, 0.81574 * 2,),
    (24, 0.56791 * 2,),
    (28, 0.41787 * 2,),
    (32, 0.32025 * 2,),
    (36, 0.25321 * 2,),
    (40, 0.20519 * 2,),
    (44, 0.16964 * 2,),
    (48, 0.14258 * 2,),
    (52, 0.12152 * 2,),
    (56, 0.10480 * 2,),
    (60, 0.09130 * 2,),
    (64, 0.08026 * 2,),
    (68, 0.07110 * 2,)
]

# for i, r in enumerate(subdiv_D100mm):
#     if i < len(subdiv_D100mm)-1:
#         print(f'{r[0]} = {r[1]}',
#               f'Multiplay = {round(r[1] / subdiv_D100mm[i+1][1], 5)}%',
#               f'Increment = {round(r[1] - subdiv_D100mm[i+1][1], 5)}')
#     else:
#         print(f'{r[0]} = {r[1]}')

for i, r in enumerate(subdiv_D100mm):
    if i > 0:
        print(
            f'{r[0]} = {r[1]}',
            f'Multiplay = {round(subdiv_D100mm[i-1][1] / r[1], 5)}%',
            f'Decrement = {round(subdiv_D100mm[i-1][1] - r[1], 5)}',
        )
    else:
        print(f'{r[0]} = {r[1]}')



print('*'*20)



print('*'*10, 'Усечения в диаметре для круга с равным подразделением но разным диаметром:')
subdiv32 = [
    (10, 0.032024 * 2,),   # Значения указаны для радиуса, поэтому умножаем на 2 чтобы получить значение для диаметра
    (20, 0.064049 * 2,),
    (30, 0.096074 * 2,),
    (40, 0.128098 * 2,),
    (50, 0.160124 * 2,),
    (60, 0.192149 * 2,),
]

print('*'*20)


# TODO: Алгоритм поиска оптимального подразделения:
#   Ищем в таблице константу для одного мм и одного количества подразделения окружности
#   Умножаем текущий диаметр окружности на константу
#   Если полученное число больше допустимого усечения в диаметре, то нужно увеличить подразделение (найти следующую константу для следующего уровня подразделения и примерить её)

subdiv = {
    '4': [
        (10, 1.66667,),  # Значения указаны для радиуса
        (20, 3.33333,),
        (30, 5,),
    ],
    '8': [
        (10, 0.488155,),
        (20, 0.976311,),
        (30, 1.46447,),
    ],
    '12': [
        (10, 0.223291,),
        (20, 0.446582,),
        (30, 0.669873,),
    ],
    '16': [
        (10, 0.126868,),
        (20, 0.253735,),
        (30, 0.380603,),
    ],
    '20': [
        (10, 0.081573,),
        (20, 0.163145,),
        (30, 0.244717,),
    ],
    '24': [
        (10, 0.05679,),
        (20, 0.11358,),
        (30, 0.17037,),
    ],
    '28': [
        (10, 0.041787,),
        (20, 0.083574,),
        (30, 0.125361,),
    ],
    '32': [
        (10, 0.032024,),
        (20, 0.064049,),
        (30, 0.096074,),
    ],
    '36': [
        (10, 0.025321,),
        (20, 0.050642,),
        (30, 0.075961,),
    ],
    '40': [
        (10, 0.020519,),
        (20, 0.04104,),
        (30, 0.061558,),
    ],
    '44': [
        (10, 0.016965,),
        (20, 0.033929,),
        (30, 0.050893,),
    ],
    '48': [
        (10, 0.014259,),
        (20, 0.028517,),
        (30, 0.042776,),
    ],
    '52': [
        (10, 0.012152,),
        (20, 0.024304,),
        (30, 0.036456,),
    ],
    '56': [
        (10, 0.01048,),
        (20, 0.020959,),
        (30, 0.03144,),
    ],
    '60': [
        (10, 0.00913,),
        (20, 0.01826,),
        (30, 0.027391,),
    ],
    '64': [
        (10, 0.008026,),
        (20, 0.016051,),
        (30, 0.024077,),
    ],
    '68': [
        (10, 0.00711,),
        (20, 0.014219,),
        (30, 0.021329,),
    ],
    '72': [
        (10, 0.006342,),
        (20, 0.012685,),
        (30, 0.019027,),
    ],
    '76': [
        (10, 0.005693,),
        (20, 0.011385,),
        (30, 0.017078,),
    ],
    '80': [
        (10, 0.005138,),
        (20, 0.010276,),
        (30, 0.015413,),
    ],
    '84': [
        (10, 0.00466,),
        (20, 0.009321,),
        (30, 0.013981,),
    ],
    '88': [
        (10, 0.004246,),
        (20, 0.008494,),
        (30, 0.01274,),
    ],
    '92': [
        (10, 0.003885,),
        (20, 0.007771,),
        (30, 0.011656,),
    ],
    '96': [
        (10, 0.003568,),
        (20, 0.007137,),
        (30, 0.010706,),
    ],
    '100': [
        (10, 0.003289,),
        (20, 0.006578,),
        (30, 0.009866,),
    ],
}


for k in subdiv.keys():
    for i in subdiv[k]:
        print(f'Div={k}, Diameter={i[0]}mm, Усечение Ø={i[1] * 2}, Усечение на 1mm={round(i[1] * 2 / i[0], 6)}')





print('*'*20)

subdiv_truncations = {}
for k in subdiv.keys():
    subdiv_truncations[k] = round(subdiv[k][0][1] * 2 / 10, 6)

pprint(subdiv_truncations, sort_dicts=False)




print('*'*20)

# TODO: Этот алгоритм имплантировать в аддон

radius = 750/2
max_truncation = 0.5
segments = 0

for i in subdiv_truncations.items():
    if round(radius * 2 * i[1], 2) <= max_truncation:
        segments = int(i[0])
        break

print(f'Для круга с диаметром = {radius * 2} мм и допуском усечения в диаметре до {max_truncation} мм оптимально {segments} сегмента(ов)')
