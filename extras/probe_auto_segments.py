#! /bin/python

import math
from pprint import pprint



# С включенной опцией Use Limit Surface
# NOTE: Для одного миллиметра в диаметре при 64 подразделений существует погрешность 0.001605 (нужно найти также для другого количества подразделений)


# Ниже таблица с измерениями разницы радиуса исходного круга и круга с примененным алгоритмом Catmul Clark (модификатором Subdivision Surface) в мм
subdiv = {
    4: [                # Ключ указывает на количество подразделений исходного круга
        (5, 1.66667,),  # Значения в мм указаны для радиуса
        (10, 3.33333,),
        (15, 5,),
    ],
    8: [
        (5, 0.488155,),
        (10, 0.976311,),
        (15, 1.46447,),
    ],
    12: [
        (5, 0.223291,),
        (10, 0.446582,),
        (15, 0.669873,),
    ],
    16: [
        (5, 0.126868,),
        (10, 0.253735,),
        (15, 0.380603,),
    ],
    20: [
        (5, 0.081573,),
        (10, 0.163145,),
        (15, 0.244717,),
    ],
    24: [
        (5, 0.05679,),
        (10, 0.11358,),
        (15, 0.17037,),
    ],
    28: [
        (5, 0.041787,),
        (10, 0.083574,),
        (15, 0.125361,),
    ],
    32: [
        (5, 0.032024,),
        (10, 0.064049,),
        (15, 0.096074,),
    ],
    36: [
        (5, 0.025321,),
        (10, 0.050642,),
        (15, 0.075961,),
    ],
    40: [
        (5, 0.020519,),
        (10, 0.04104,),
        (15, 0.061558,),
    ],
    44: [
        (5, 0.016965,),
        (10, 0.033929,),
        (15, 0.050893,),
    ],
    48: [
        (5, 0.014259,),
        (10, 0.028517,),
        (15, 0.042776,),
    ],
    52: [
        (5, 0.012152,),
        (10, 0.024304,),
        (15, 0.036456,),
    ],
    56: [
        (5, 0.01048,),
        (10, 0.020959,),
        (15, 0.03144,),
    ],
    60: [
        (5, 0.00913,),
        (10, 0.01826,),
        (15, 0.027391,),
    ],
    64: [
        (5, 0.008026,),
        (10, 0.016051,),
        (15, 0.024077,),
    ],
    68: [
        (5, 0.00711,),
        (10, 0.014219,),
        (15, 0.021329,),
    ],
    72: [
        (5, 0.006342,),
        (10, 0.012685,),
        (15, 0.019027,),
    ],
    76: [
        (5, 0.005693,),
        (10, 0.011385,),
        (15, 0.017078,),
    ],
    80: [
        (5, 0.005138,),
        (10, 0.010276,),
        (15, 0.015413,),
    ],
    84: [
        (5, 0.00466,),
        (10, 0.009321,),
        (15, 0.013981,),
    ],
    88: [
        (5, 0.004246,),
        (10, 0.008494,),
        (15, 0.01274,),
    ],
    92: [
        (5, 0.003885,),
        (10, 0.007771,),
        (15, 0.011656,),
    ],
    96: [
        (5, 0.003568,),
        (10, 0.007137,),
        (15, 0.010706,),
    ],
    100: [
        (5, 0.003289,),
        (10, 0.006578,),
        (15, 0.009866,),
    ],
}


for k in subdiv.keys():
    for i in subdiv[k]:
        print(f'Div={k}, Radius={i[0]}mm, Усечение по радиусу={i[1]}, Усечение для 1mm={round(i[1] / i[0], 6)}')





print('*'*20)

subdiv_truncations = {}
for k in subdiv.keys():
    subdiv_truncations[k] = round(subdiv[k][0][1] / subdiv[k][0][0], 9)

pprint(subdiv_truncations, sort_dicts=False)




print('*'*20)

# TODO: Этот алгоритм имплантировать в аддон

radius = 300
max_truncation = 0.25
segments = 0

for i in subdiv_truncations.items():
    if round(radius * i[1], 2) <= max_truncation:
        segments = i[0]
        break

print(f'Для круга с диаметром = {radius * 2} мм и допуском усечения в диаметре до {max_truncation *2} мм оптимально {segments} сегмента(ов)')




print('*'*20)

xxx = {4: 0.333334,
 8: 0.097631,
 12: 0.044658,
 16: 0.025374,
 20: 0.016315,
 24: 0.011358,
 28: 0.008357,
 32: 0.006405,
 36: 0.005064,
 40: 0.004104,
 44: 0.003393,
 48: 0.002852,
 52: 0.00243,
 56: 0.002096,
 60: 0.001826,
 64: 0.001605,
 68: 0.001422,
 72: 0.001268,
 76: 0.001139,
 80: 0.001028,
 84: 0.000932,
 88: 0.000849,
 92: 0.000777,
 96: 0.000714,
 100: 0.000658}

for k in xxx.keys():
    if k > 4:
        print(k, round(xxx[k-4] - xxx[k], 6), f'Усечение на +{round(100 - xxx[k] / (xxx[k-4]/100), 2)}%')


TODO: Сделать скрипт в блендере который соберёт значения для более чем 100 сегментов.
